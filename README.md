Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему выбрали именно этот. 
---
Подразумеваю, что используется флудконтроль, как отдельное приложение, будь оно консольным или микросервисным.

Изначально надо подумать о том, какую структуру создать, чтобы удовлетворить все, что необходимо реализовать.

### Как хранить запросы?
 1. Напрашивается варианты о условном массиве, который хранит IP, с которых пришел запрос
 2. Отметается, непонятно как хранить время, кортежем? даже если так, то удаление из середины/начала массива - долгое, а нам, предположительно, придется проверять тысячи IP, а значит тратить время на тысячи IPшников слишком долго
 3. После этого приходит на мысли другие структуры данных, куча и мапа. Кучи из "коробки" в golang нет, зато есть мапа. 
 4. Ключом в мапу явно можно записывать IP или ID юзера, что хранить как значение? Выглядит логичным использовать массив времен прихода запроса, т.к. мы явно не будем использовать во флуд контроле как maxRequests >1000, то перебрать 10 значений не так долго.
 5. однако, существуют и другие структуры данных, позволяющие хранить время - FIFO, LIFO, Deque. Очередь(FIFO) и дек(Deque) позволят нам добавлять в конец и pop'ать из начала за константу, не требуя перестановку элементов.
### Как синхронить с разными приложениями?
 1. Зачем синхронить впринципе? Если наш "потенциальный" дудосер будет атаковать M наших сервисов, которые обращаются к нашему флудконтролю, то мы не сможем его остановить в корректный момент.
 2. В целом, существует множество разных способов синхронизации, начиная с семофоров, заканчивая ивентами/барьерами. Но мы синхроним не потоки одного процесса, а обращения из разных процессов к нашему флудконтролу. Самое легкое, что можно реализовать в таком случае - мьютекс.
 3. Поэтому при входе в функцию мы лочим функцию и сразу же отложенно анлочим.
### Остальные переменные в структуре
 - timeInterval - переменная для хранения "последних N секунд", т.е. к ней обращаются для сравнения когда пришел запрос и какое сейчас время.
 - maxRequests - переменная для хранения количества вызовов функции за N секунд

### NewFloodControl
функция для создания интерфейса, принимает в себя N секунд, K запросов.

### Check - реализация
 1. Как уже говорилось в блоке про синхронизацию, начинаем с лока и отложенного анлока
 2. нам нужно знать, в какой момент мы сейчас обращаемся в функцию, засекаем время.
 3. Нам нужно очистить "старые" запросы и записать новые. Забираем все запросы(весь дек запросов), которые пользователь совершал
    1. Если пользователь не делал запросов с создания процесса флудконтрола, то создаем для него пустой дек
    2. Если дек хоть как-то заполнен, проходимся по нему и проверяем, чтобы спереди(.Front()) был не старше 10 секунд, попаем все, что старше 10 секунд.
4. Если все равно, кол-во запросов >= количества макс запросов, то мы возвращаем ошибку
5. в ином случае, добавляем в конец наш запрос и возвращаем успех.

### main
1. забираем аргументы, нам нужно количество секунд и количество запросов.
2. Секунды и запросы должны быть целочисленные и положительные, делаем проверки на это.
3. инициализируем наш флудконтрол
4. ждем прихода запросов. Реализован это ожидание в "глупого", т.к. по ТЗ не просится реализовать его, как микросервис/межпроцессорное приложение.

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.
